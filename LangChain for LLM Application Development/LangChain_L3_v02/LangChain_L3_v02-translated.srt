1
00:00:05,000 --> 00:00:11,960
在这节课中，Harrison将为大家讲解LangChain最关键的构建模块，也就是链（Chain）。

2
00:00:11,960 --> 00:00:17,440
链通常将大型语言模型（LLM）与提示词（Prompt）结合在一起。

3
00:00:17,440 --> 00:00:26,560
有了这个构建模块，你还可以将一堆这样的构建模块组合在一起，对你的文本或其他数据按顺序进行操作。

4
00:00:26,560 --> 00:00:28,400
我已经等不及想要深入了解它了。

5
00:00:29,000 --> 00:00:33,680
好的，首先，我们将像以前一样加载环境变量。

6
00:00:33,680 --> 00:00:37,360
然后我们还要加载一些即将使用的数据。

7
00:00:37,360 --> 00:00:44,440
这些链的强大之处在于，它们可以一次处理多个输入。

8
00:00:44,440 --> 00:00:46,720
这里，我们将加载一个Pandas DataFrame。

9
00:00:46,720 --> 00:00:52,520
Pandas DataFrame只是一个包含许多不同数据元素的数据结构。

10
00:00:52,520 --> 00:00:54,600
如果你不熟悉Pandas，不用担心。

11
00:00:54,600 --> 00:00:58,720
这里的重点是，我们正在加载一些数据，稍后将会被用到。

12
00:00:58,760 --> 00:01:04,400
如果我们查看这个Pandas DataFrame，可以看到有一个产品列和一个评论列。

13
00:01:04,400 --> 00:01:08,680
这些行中的每一行都是一个不同的数据记录，我们可以开始通过我们的链进行传递。

14
00:01:08,680 --> 00:01:12,280
首先我们要介绍的链是LLMChain。

15
00:01:12,280 --> 00:01:18,400
这是一个简单但非常强大的链，后面要介绍的很多链它都能支持。

16
00:01:18,400 --> 00:01:21,360
我们将导入三个不同的库。

17
00:01:21,360 --> 00:01:25,080
我们将导入OpenAI模型，即LLM。

18
00:01:25,080 --> 00:01:28,640
我们将导入ChatPromptTemplate，这是提示词（Prompt）相关的。

20
00:01:28,640 --> 00:01:30,160
然后我们将导入LLMChain。

21
00:01:30,160 --> 00:01:36,240
首先，我们要初始化我们想要使用的语言模型。

22
00:01:36,240 --> 00:01:44,120
我们将用一个比较高的temperature值来初始化ChatOpenAI，这样能获得一些有意思的结果。

23
00:01:44,120 --> 00:01:49,160
现在我们要初始化一个提示词模板，这个提示词模板将接收一个名为产品（product）的变量。

24
00:01:49,160 --> 00:01:54,880
它会要求LLM根据产品名称，为制作该产品的公司取一个最佳的公司描述名称。

25
00:01:55,720 --> 00:01:59,280
最后，我们将这两者结合成一条链。

26
00:01:59,280 --> 00:02:03,000
这就是我们所说的LLMChain，非常简单。

27
00:02:03,000 --> 00:02:06,280
它只是LLM和提示词模板的结合。

28
00:02:06,280 --> 00:02:11,560
这条链将提示词模板和LLM按顺序连接起来。

29
00:02:11,560 --> 00:02:17,960
如果我们有一个名为“双人床床单套装”的产品，我们可以通过使用“chain.run”将它传入链，并运行链。

30
00:02:17,960 --> 00:02:24,200
它会在后台格式化提示词，然后将格式化后的提示词传给LLM。

31
00:02:24,600 --> 00:02:29,520
我们可以看到LLM给这个生产床单的公司取了个名字叫做"皇家寝具"。

32
00:02:29,520 --> 00:02:37,400
建议你暂停视频，去Notebook输入你想要的产品描述，看看这条链会输出什么结果。

33
00:02:37,400 --> 00:02:43,840
LLMChain是最基本的链类型，以后经常会被用到。

34
00:02:43,840 --> 00:02:48,600
我们来看看下一种常用的链，也就是"顺序链（Sequential Chains）"。

35
00:02:48,600 --> 00:02:52,720
顺序链是将一系列链一个接一个地运行。

36
00:02:53,200 --> 00:02:57,040
首先，你需要导入SimpleSequentialChain。

37
00:02:57,040 --> 00:03:02,200
当我们的子链都只需要一个输入并且只返回一个输出时，这个方法很有用。

38
00:03:02,200 --> 00:03:08,360
这里我们首先创建一条链，它使用LLM和提示词模板。

39
00:03:08,360 --> 00:03:14,840
这个提示词模板将接受输入一个产品参数，并返回最佳的产品所属公司描述名称。

40
00:03:14,840 --> 00:03:16,240
那将是第一条链。

41
00:03:16,240 --> 00:03:19,280
然后我们要创建第二条链。

42
00:03:19,760 --> 00:03:26,320
第二条链会接收公司名称，然后输出一个20字的公司描述。

43
00:03:26,320 --> 00:03:31,000
你可以想象这些链需要一条接一条地运行，

44
00:03:31,000 --> 00:03:35,320
其中第一条链会输出公司名称，然后会将它传递给第二条链。

45
00:03:35,320 --> 00:03:42,680
通过创建一个SimpleSequentialChain我们可以很容易的实现这一点，参数中包含了两条链的描述。

46
00:03:42,680 --> 00:03:45,320
我们将这条链命名为overall_simple_chain。

47
00:03:47,240 --> 00:03:52,240
现在，你可以在任何产品描述上运行这条链。

48
00:03:52,240 --> 00:03:57,114
我们可以用之前的“双人床床单套装”来测试，

49
00:03:57,115 --> 00:04:00,557
让我们运行它看看，先是输出了“皇家寝具”，

50
00:04:00,558 --> 00:04:06,280
然后将它传递到第二条链，得出关于该公司可能的描述。

51
00:04:06,280 --> 00:04:12,840
简单顺序链（SimpleSequentialChain）在只有一个输入和一个输出时表现非常好。

52
00:04:12,840 --> 00:04:16,680
但是当有多个输入或多个输出时该怎么办？

53
00:04:16,920 --> 00:04:20,080
我们可以通过使用常规的SequentialChain来实现这一点。

54
00:04:20,080 --> 00:04:22,120
让我们导入它。

55
00:04:22,120 --> 00:04:25,920
然后你可以创建一系列链，后面我们将依次调用这些链。

56
00:04:25,920 --> 00:04:29,160
我们将使用上面的数据，其中包含一篇评论。

57
00:04:29,160 --> 00:04:34,840
首先，我们将用第一条链将评论翻译成英语。

58
00:04:34,840 --> 00:04:41,840
然后用第二条链，我们将用一句话总结这篇评论。

59
00:04:41,840 --> 00:04:46,840
这里用的是之前生成的英语评论。

60
00:04:47,360 --> 00:04:54,200
第三条链将检测评论最初是用什么语言写的。

61
00:04:54,200 --> 00:05:00,280
注意看，这里使用的是"Review"变量，表示原始的评论。

62
00:05:00,280 --> 00:05:05,480
最后，第四条链将接收多个输入。

63
00:05:05,480 --> 00:05:13,280
它将接收我们用第二条链得到的摘要"summary"变量和我们用第三条链得到的语言"language"变量。

64
00:05:13,760 --> 00:05:18,280
要求后续对摘要回复时，使用指定的语言。

65
00:05:18,280 --> 00:05:25,960
关于所有这些子链，需要注意的是输入名和输出名需要非常精确，这非常重要。

66
00:05:25,960 --> 00:05:28,520
所以这里我们接收"Review"。

67
00:05:28,520 --> 00:05:31,120
这是一个在开始时传入的变量。

68
00:05:31,120 --> 00:05:35,320
我们可以看到我们明确设置了输出名为"English_Review"。

69
00:05:35,320 --> 00:05:42,040
这在下面的下一个提示中使用，我们用相同的变量名接收"English_Review"。

70
00:05:42,800 --> 00:05:47,840
我们将该链的输出名设置为"summary"，我们可以看到它在最后一条链中使用。

71
00:05:47,840 --> 00:05:56,080
第三个提示词模板接收原始的"Review"变量和输出"language"，这些在最后的提示词模板中会被再次使用。

72
00:05:56,080 --> 00:06:03,400
因为有很多不同的输入和输出一起运行，确保这些变量名称完全一致非常重要。

74
00:06:03,400 --> 00:06:07,200
如果出现任何关键性的错误，一定要检查变量名是否一致。

75
00:06:07,200 --> 00:06:14,680
简单顺序链（Simple Sequential Chain）接收多条链，每条链都有一个输入和一个输出。

76
00:06:14,680 --> 00:06:23,720
一图胜千言，可以看这张幻灯片的图示，一条链的输出传入另一条链作为输入，一个接一个。

77
00:06:23,720 --> 00:06:29,640
在这里，我们可以看到顺序链（Sequential Chain）的图示，并把它跟前面的简单顺序链进行比较。

78
00:06:29,640 --> 00:06:34,360
你会注意到链中的任何步骤都可以接收多个输入变量。

79
00:06:34,960 --> 00:06:41,960
当你有复杂的下游链需要和多个上游链组合，这会非常有用。

80
00:06:41,960 --> 00:06:47,440
有了所有这些链之后，我们可以轻松地将它们组合在顺序链（SequentialChain）中。

81
00:06:47,440 --> 00:06:53,440
首先，我们将创建的四条链作为数组保存到chains变量。

82
00:06:53,440 --> 00:06:58,440
我们用一个人类输入也就是"Review"来创建"inputs_variables"。

83
00:06:58,440 --> 00:07:02,680
然后我们想返回所有中间输出：

84
00:07:02,680 --> 00:07:05,520
"English_Review"、"summary"，然后是"followup_message"。

85
00:07:05,520 --> 00:07:10,480
现在我们可以传一些数据来运行试试。

86
00:07:10,480 --> 00:07:15,280
让我们选择一条评论并传递给整条链。

87
00:07:15,280 --> 00:07:25,400
我们可以看到原始的"Review"似乎是法语的。

88
00:07:25,400 --> 00:07:28,480
我们可以看到"English_Review"作为翻译。

89
00:07:28,480 --> 00:07:35,080
我们可以看到评论的"summary"，然后我们可以看到法语的"followup_message"。

90
00:07:35,080 --> 00:07:39,120
建议你暂停视频，尝试输入不同的内容，并运行看看效果。

91
00:07:39,120 --> 00:07:43,360
到目前为止，我们已经介绍了LLMChain和顺序链（Sequential Chain）。

92
00:07:43,360 --> 00:07:46,440
但是，如果你想完成更复杂的任务呢？

93
00:07:46,440 --> 00:07:53,160
一个相当常见的基本操作是，根据输入内容路由到某条链来处理你的输入。

94
00:07:53,720 --> 00:08:03,000
可以想象以下，如果你有多条子链，每条子链专门负责处理某种特定类型的输入，这种情况下你可以使用路由链（Router Chain），

95
00:08:03,000 --> 00:08:07,560
它首先判断该使用哪条子链，然后将输入传递到相应的子链。

96
00:08:07,560 --> 00:08:16,960
举一个具体的例子来看看我们如何根据输入的内容来路由到不同类型的链。

97
00:08:16,960 --> 00:08:19,920
这里我们有不同的提示词。

98
00:08:19,920 --> 00:08:22,760
一个提示词适合回答物理问题。

99
00:08:22,880 --> 00:08:28,560
第二个提示词适合回答数学问题，第三个提示词适合历史，第四个提示词适合计算机科学。

100
00:08:28,560 --> 00:08:31,160
让我们定义所有这些提示词模板。

101
00:08:31,160 --> 00:08:39,040
有了这些提示模板后，我们可以提供更多关于它们的信息。

102
00:08:39,040 --> 00:08:42,320
可以给每个模板起个名字，然后写个描述。

103
00:08:42,320 --> 00:08:46,640
这个物理模板的描述非常适合回答物理问题。

104
00:08:46,640 --> 00:08:54,080
这些信息将传递给路由链，路由链会根据这些信息来决定什么时候该使用哪条子链。

105
00:08:59,857 --> 00:09:02,840
现在让我们导入其他需要的链类型。

106
00:09:02,840 --> 00:09:05,040
这里我们需要用MultiPromptChain，

107
00:09:05,040 --> 00:09:10,640
这是一种特定类型的链，可以用来在多个不同提示词模板之间路由。

108
00:09:10,640 --> 00:09:17,800
如你所见，我们所有的选项都是提示模板，但实际上不止是可以路由这一种类型，

109
00:09:17,840 --> 00:09:20,240
除此之外你也可以在任何其他类型的链之间路由。

110
00:09:20,240 --> 00:09:24,120
这里还需要引用LLMRouterChain。

111
00:09:24,120 --> 00:09:28,480
这个程序借助大语言模型的帮助在不同的子链之间路由。

112
00:09:28,480 --> 00:09:32,040
这就是为什么上面需要提供名称和描述，语言模型根据这些信息判断如何路由。

113
00:09:32,040 --> 00:09:35,040
我们还要导入一个RouterOutputParser。

114
00:09:35,040 --> 00:09:44,240
这个解析器将LLM输出解析成一个字典，根据字典的内容可以在下游确定使用哪条链，以及该链的输入应该是什么。

115
00:09:47,600 --> 00:09:49,040
现在我们可以开始使用它了。

116
00:09:49,040 --> 00:09:53,720
首先，让我们导入并定义将要使用的语言模型。

117
00:09:53,720 --> 00:09:59,040
接下来创建目标链，

118
00:09:59,040 --> 00:10:01,880
路由链会根据输入的内容来调用这些目标链之一。

119
00:10:01,880 --> 00:10:07,160
如你所见，每个目标链本身就是一个语言模型链，即LLMChain。

120
00:10:07,160 --> 00:10:12,840
除了目标链，我们还需要一个默认链。

121
00:10:12,840 --> 00:10:17,840
默认链是在路由找不到合适的子链调用时，用来备用的一条链路。

122
00:10:17,840 --> 00:10:25,840
在上面的例子中，当输入问题与物理、数学、历史或计算机科学无关时，就会调用这条链路。

123
00:10:25,840 --> 00:10:33,840
现在我们定义一个路由的提示词模板，让LLM根据提示词的内容在不同链之间路由。

124
00:10:33,840 --> 00:10:40,440
这里包含了完成任务的说明，以及输出内容的的格式。

125
00:10:40,440 --> 00:10:44,840
让我们把这些部分组合起来，构建路由链。

126
00:10:45,640 --> 00:10:50,480
首先，我们通过使用上面定义的目标来创建完整的路由模板。

127
00:10:50,480 --> 00:10:54,320
这个模板适用于许多不同类型的目标。

128
00:10:54,320 --> 00:10:58,520
建议你在这里暂停，然后尝试添加不同类型的目标。

129
00:10:58,520 --> 00:11:05,000
在这里，除了物理、数学、历史和计算机科学，你还可以添加其他学科，如英语或拉丁语。

130
00:11:05,000 --> 00:11:14,240
接下来，我们从这个模板创建提示词模板，然后传入LLM和整个路由器提示词，创建路由链。

131
00:11:15,080 --> 00:11:17,440
注意这里有RouterOutputParser。

132
00:11:17,440 --> 00:11:23,240
这很重要，因为它会帮助决定这条链在哪些子链之间路由。

133
00:11:25,557 --> 00:11:30,000
最后，把所有内容放在一起，我们可以创建整条链。

134
00:11:30,000 --> 00:11:33,520
这里有一个路由链，定义在这里，

135
00:11:33,520 --> 00:11:36,280
它有目标链，我们在这里传入。

136
00:11:36,280 --> 00:11:38,280
然后传入默认链，

137
00:11:38,280 --> 00:11:41,200
现在可以使用这条链了。

138
00:11:41,200 --> 00:11:43,120
让我们向它提问试试。

139
00:11:43,760 --> 00:11:53,900
如果我们问一个关于物理的问题，希望能看到它被路由到物理链，输入是“什么是黑体辐射？”

140
00:11:53,901 --> 00:11:56,680
然后这个问题会传到下面的链。

141
00:11:56,680 --> 00:12:02,240
可以看到回复非常详细，包含了很多物理细节。

142
00:12:02,240 --> 00:12:06,560
建议你在这里暂停视频，自己尝试输入不同的内容试试。

143
00:12:06,560 --> 00:12:12,040
可以尝试我们之前定义的路由链中的其他链。

144
00:12:12,640 --> 00:12:16,057
比如，如果问一个数学问题，

145
00:12:23,329 --> 00:12:27,160
应该看到它被路由到数学链，然后把问题传入数学链。

146
00:12:31,971 --> 00:12:37,560
还可以试试当我们提出一个与这些子链都无关的问题时会发生什么。

147
00:12:37,560 --> 00:12:43,160
这里我们问一个关于生物学的问题，可以看到它选择的链是“无”。

148
00:12:43,160 --> 00:12:48,760
这意味着问题会被传递到默认链，也就是直接当做一个通用问题去问语言模型。

149
00:12:48,760 --> 00:12:52,360
幸运的是，语言模型对了解很多生物学知识，所以它还是可以帮助我们回答这个问题。

150
00:12:52,360 --> 00:13:00,200
现在我们已经学习了这些基本的构建块类型的链，我们可以尝试将它们组合在一起，创建有趣的应用。

151
00:13:00,200 --> 00:13:06,400
在下一节课程中，我们将介绍如何创建一个可以基于文档问答的链。
