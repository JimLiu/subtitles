在这个部分，我们将关注处理输入的任务，
即接收输入并生成有用输出的任务，
通常是通过一系列步骤完成的。
有时模型在回答特定问题之前需要详细推理问题，

如果你参加过我们之前的课程\N“ChartGPT Prompt Engineering for
Developers”，你会看到很多这方面的例子。
有时模型可能会因为急于得出结论而出现推理错误，
所以我们可以重新构建查询，\N要求模型进行一系列相关的
推理步骤在给出最终答案之前，这样它就
可以更长时间、更有条理地思考问题。
总的来说，我们把让模型分步推理的策略\N称为链式思维推理（Chain of Thought Reasoning）。

对于某些应用，模型在得出最终答案的过程中\N所使用的推理过程可能不适合与用户共享。

例如，在教学辅导应用中，我们可能希望鼓励学生
自己解答问题，但模型对学生解答的推理过程
可能会泄露答案给学生。
“内心独白”是一种可以用来缓解这个问题的策略。
这只是一种时髦的比喻，\N意思是将模型的推理过程对用户进行隐藏。
内心独白的方案是指示模型\N将输出的某些部分放入结构化格式，
以便将这些内容隐藏起来不让用户看到。
然后，在将输出呈现给用户之前，\N输出内容会被过滤，只有部分内容对用户可见。
所以请记住前一个教学视频中的分类问题，我们
要求模型将客户查询分类为主要和次要类别。
根据这个分类，我们可能想采取不同的指示。
想象一下，客户查询已经被归类到产品信息类别。
在接下来的指示中，
我们会想要包含关于我们拥有的产品的信息。
所以，在这种情况下，分类将是：\N主类，一般查询，次类，产品信息。

那么让我们从那里开始深入一个例子。
那么让我们从初始设置开始。
对于这个内心独白的例子，
我们将从一直在使用的相同分隔符开始。
现在让我们看一下系统消息。
所以我们在这里所做的是\N在得出结论之前要求模型对答案进行推理。
所以指令是：“按照这些步骤回答客户查询。
客户查询将用四个井号分隔，我们的分隔符。”
然后我们把这个分成几步。
所以第一步是：决定用户\N是否在询问关于特定产品或产品的问题。

并且产品类别不算数。
第二步，因此，\N如果用户询问有关特定产品的信息，
确定这些产品是否在以下列表中。
现在我们已经包括了一份可用产品清单。
所以这里我们有五种可用的产品，\N它们都是各种类型的笔记本电脑，这些都是虚构的产品。
它们实际上是由GPT-4生成的。
在第三步中，如果消息包含上述列表中的产品，
列出用户在其消息中所做的任何假设。
例如，笔记本电脑X比笔记本电脑Y大，或者
例如，笔记本电脑Z有两年保修期。
第四步是，如果用户有任何假设，
根据您的产品信息判断假设是否正确。
第五步是：“首先，\N礼貌地纠正客户的错误假设（如果适用）。”
只提及或参考五个可用产品中的产品。
因为商店目前仅销售这五款产品。
以友好的语气回答客户。
对于像GPT-4这样更高级的语言模型\N来说，这些非常繁琐的指示可能是不必要的。
然后我们将要求模型使用以下格式。
所以第一步，分隔符，它的推理。
第二步，分隔符，推理，依此类推。
使用分隔符意味着我们以后\N更容易将这个回答提供给客户。
把分隔符之前的所有内容都移除。
现在让我们测试一个用户消息。
所以我们的消息是：\N“BlueWave Chromebook比TechPro台式机贵多少？”
那么让我们看看这两款产品。
BlueWave Chromebook售价为249.99美元，
而TechPro台式机实际上售价为999.99美元。
这实际上并不正确。
那么让我们看看模型如何处理这个用户请求。
所以我们将其格式化为\N我们的消息数组，然后我们会得到返回结果。
然后我们会打印出来。
所以我们希望的是
模型能够理解所有这些\N不同的步骤，并意识到
用户做出了错误的假设，然后
在最后一步礼貌地纠正用户。
所以在这一个提示（Prompt）中，\N我们实际上保持了
系统可能处于的许多不同的复杂状态。
所以在任何给定的时刻，\N都可能有来自前一步的不同输出，
我们会想要做一些不同的事情。
例如，如果用户在第三步没有做任何假设，
那么在第四步，\N我们实际上不会有任何输出。
所以这对模型来说是一个相当复杂的指令。
那么让我们看看它是否做对了。
所以第一步，用户在询问关于特定产品的问题。
他们在询问这两款产品之间的价格差异。
用户认为BlueWave Chromebook比
TechBook Pro更贵，\N而这个假设实际上是错误的。
它通过推理，花更长的时间来思考这个问题。
就像人类在回答任何问题时\N也需要花一些时间来推理一样，
如果模型也有时间去思考，它的表现会更好。
所以最后对用户的回答是\NBlueWave Chromebook实际上比TechBook Pro便宜。
TechBook Pro台式电脑售价为999.99美元，\N而BlueWave Chromebook售价为249.99美元。
让我们看另一个用户消息的例子。
此时，也可以随时暂停视频，\N尝试您自己的消息。
让我们格式化这个用户消息。
所以问题是：“你们卖电视吗？”
如果您还记得我们的产品列表中，\N我们只列出了不同的电脑。
让我们看看模型会说什么。
所以在这种情况下，第一步，\N用户询问商店是否出售电视，但是
电视并未列在可用产品中。
因此，如您所见，模型\N接着跳到回应用户的步骤，因为它
意识到中间步骤实际上并不需要。
我要说的是，我们确实要求以这种特定格式输出。
从技术上讲，模型并没有完全遵循我们的要求。
再次强调，更先进的模型会更擅长做到这一点。
在这种情况下，\N我们对用户的回复是：“对不起，但是
我们商店里不卖电视。”
然后列出了可用的产品。
请随意尝试一些您自己的回答。
现在，我们只想要这部分返回的内容。
我们不想把前面的部分展示给用户。
所以我们可以做的\N实际上就是在最后一次出现
这个分隔符标记\N或四个井号字符串的地方分割字符串。
然后只打印模型输出的最后一部分。
让我们编写代码来获取这个字符串的最后一部分。
因此，我们将使用一个\N try except 块来优雅地处理错误，以防
模型有某种不可预测的输出，而且
实际上并不使用这些字符。
我们要将response变量\N赋值给final_response。
然后我们要使用分隔符来将字符串分割成数组。
因为我们想要找到它最后一次出现的位置，
然后只想要输出数组中的最后一项。
最后再去除前后空格。
因为如您所见，字符后面可能会有空格。
然后我们要处理任何可能得异常错误。
并有一个备用返回结果。
那就是：\N“对不起，我现在遇到了麻烦。


请尝试提问另一个问题。”
然后让我们打印最终结果。
如您所见，我们只是\N对字符串裁剪，从而获得最终输出。
如果我们将它集成到应用程序中，\N这就是我们要向用户展示的内容。
总的来说，我只是想指出，
这个提示（Prompt）\N对于这个任务可能有些复杂。
你实际上可能不需要所有这些中间步骤。
所以，为什么不尝试看看\N你能否在你自己的提示（Prompt）中\N找到一种更简单的方法来完成相同的任务。
总的来说，需要反复尝试\N才能找到提示（Prompt）\N的最佳平衡点。
所以在决定使用一个\N提示（Prompt）之前，最好尝试\N多种不同的提示（Prompt）。
在下一个视频中，\N我们将学习另一种处理复杂任务的策略，
通过将这些复杂任务分解成\N一系列更简单的子任务，
而不是试图在一个\N提示（Prompt）中完成整个任务。