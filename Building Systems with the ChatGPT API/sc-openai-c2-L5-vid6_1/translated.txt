在这个视频中，我们将学习如何通过将多个Prompt链接在一起，将复杂任务分解为一系列更简单的子任务。

你可能会想，为什么要将任务分解为多个Prompt，而不是
通过一个Prompt和一系列思维推理来实现呢？就像我们在上一个视频中学到的那样。
我们已经证明，语言模型非常擅长遵循复杂的指令，
尤其是像GPT-4这样的更先进的模型。
那么让我用两个类比来解释为什么我们要比较思维链推理和多个Prompt链。
第一个类比是一次性做好一桌饭菜与分阶段做好一桌饭菜之间的区别。
使用一个长而复杂的指令就像一次性做一桌丰盛的饭菜，
你必须同时使用多种食材、利用高超的烹饪技巧和掌握好火候。
同时使用所有食材，并要确保每个菜都煮得火候刚好，这是一件非常有挑战的事。
另一方面，链式Prompt（Chaining prompts）就像分阶段做一桌饭菜，你可以集中注意力
一次处理一个菜，确保每个菜在做下一个菜之前都煮好了。
这种方法将任务的复杂性分解，使其更易于管理，降低出错的可能性。
当然，要是做一顿非常简单的饭菜，这种方法可能是不必要的，过于复杂。
对于这件事，对于有些程序经验的同学来说，一个更好的类比是
意大利面条式代码，所有代码都在一个长文件中，整个程序只有一个模块。
之所以意大利面条式代码难以阅读并且难以调试，主要原因是其模糊性和复杂的
逻辑部分之间的依赖关系。
对于提交给语言模型的复杂单步任务，也是类似的。
链式Prompt这种策略很强大，你设计一个工作流，
把各种中间状态保存下来，然后根据当前的状态决定后续操作。
举一个例子，当客户查询后，你根据查询的内容对它进行分类，
那么当前的状态将是分类，从分类结果可以得知它是一个账户问题或者是一个产品问题。
然后根据这个状态的分类结果，你可以采取不同的行动。
每个子任务很单一，只需要包含执行子任务所需的指令，这使得
系统更容易管理，确保模型具有执行任务所需的所有信息
并减少错误的可能性，正如我前面提到的那样。
这种方法还可以降低成本，因为Prompt越长，消耗的Token就越多，成本越高，
而在某些情况下，在Prompt中列出所有步骤可能是不必要的。
这种方法的另一个好处是，它也更容易测试哪些步骤可能
更容易出错，或者在特定步骤中让人工介入。
所以总结一下，因为这是一个很长的解释，与其在一个Prompt中
用几十个要点或几段文字描述一个复杂的工作流程，就像在之前的视频中那样，
不如在外部跟踪状态，然后根据需要注入相应的指令。
那么，是什么使问题变得复杂？
我认为一般来说，如果有很多不同的指令，并且
潜在地所有这些指令都可能适用于任何给定的情况，那么问题就会
变得复杂，因为这些情况可能会让模型难以推理该做什么。
随着您与这些模型的构建和互动越来越多，您将能
更直观的了解，何时使用这种链式Prompt的策略还是之前一条复杂Prompt的策略。
还有一点我没提到的额外好处：它还允许
模型在必要时在工作流程的某些点调用外部工具。
例如，它可以在产品目录中查找某些信息，或者调用API，或者搜索知识库。
这是单个Prompt无法实现的。
接下来让我们通过一个例子来深入了解。
我们将使用与上一个视频相同的例子，我们想回答
关于特定产品的客户问题。
但这次我们将使用更多的产品，并将步骤分解为多个不同的Prompt。
我们将使用与之前视频相同的分隔符。
让我们阅读一下系统消息。
您将要处理一段客户服务查询。
客户服务查询内容会以四个井号字符分隔。
输出一个Python对象列表，其中每个对象具有以下格式：
类别，这是以下预定义字段之一。
或产品。
这是一个产品列表，必须在下面的允许产品中找到。
类别和产品必须在客户服务查询中找到。
如果提到了产品，必须将其与下面允许产品列表中的正确类别关联。
如果没有找到产品或类别，请输出一个空列表。
现在我们有了允许的产品列表。
所以我们有类别，然后是这些类别中的产品。
我们最后的指示是仅输出对象列表，不包含其他内容。
接下来我们有用户消息。
所以这个消息是：“告诉我关于smartx pro手机和fotosnap相机，那个单反的。
还告诉我你们有哪些电视。”
用户询问了两个特定的产品（手机和相机）。
还有电视这个类别。
这两个产品都在允许的产品列表中。
然后还有一个电视部分。
将系统消息和用户消息格式化为消息数组。
然后我们从模型中得到结果。
如你所见，对于我们的输出，我们有一个对象列表。
每个对象都有类别和产品。
我们有SmartX Pro手机和FotoSnap DSLR相机。
在最后一个对象中，我们实际上只有一个类别，因为我们没有提到任何特定的电视。
输出这种结构化响应的好处是我们可以将其读入并解析为一个Python列表，这非常好。
那么让我们再试一个例子。
我们的第二个用户消息是：“我的路由器不能用。”
如果你注意到我们的列表中，实际上没有任何路由器。
让我们组织好消息内容，并从模型获得结果。
如您所见，在这种情况下，输出是一个空列表。
现在我们有了这个步骤来识别类别和产品，
如果找到了任何产品和类别，我们希望将有关这些请求产品的一些信息
和类别，都加入到Prompt中，以便我们更好地回答客户问题。
在我们的工作流程中，现在在这个Prompt运行之后的状态，要么是列出了产品，要么是没有列出产品。
如果是没有列出产品的情况，我们不会尝试查找任何东西，因为没有东西可供查找。
如果我要把这个功能真正地构建成一个系统，我可能会使用类别名称，
也许像计算机和笔记本电脑之类的东西，以避免空格和特殊字符带来的奇怪问题。
但现在这应该可以工作。
现在我们想查找一些关于用户提到的产品的信息。
关于这种手机、这种相机和电视机。
我们需要有个产品目录来查找这些信息。
这里有我刚刚粘贴的产品信息。
如您所见，我们的商店有大量的产品。
而所有这些产品都是假的，实际上是由GPT-4生成的。
对于每个产品，我们有几个不同的字段，
有：名称、类别、品牌、保修等等。
"products"只是一个从产品名称到包含产品信息的对象的字典。
注意每个产品都有一个类别。
请记住，我们要查找用户询问的产品的信息。
我们需要定义一些辅助函数，以便根据产品名称查找产品信息。
让我们创建一个函数，可以用来根据名称获取产品。
我们输入名称。
我们将返回产品字典，我们将从字典中获取key是name的值。
我们的备选方案暂时没有。
我们还想定义另一个辅助函数，以获取某个类别的所有产品。
例如，当用户向我们询问电视时，
我们希望加载所有的不同的电视的所有信息。
通过输入类别名称来获取类别下的产品。
为此，我们要遍历产品字典中的所有产品，
并检查所有离别和要查询类别相同的产品。
如果是这样，我们想要返回这个。
我们将按照以下方式进行。
首先，我们要遍历每个产品，我们必须获取值，因为我们需要
实际访问值中的类别。
然后，如果产品类别等于我们的输入类别，我们将返回此产品。
让我们为这些辅助函数的每一个做一个例子。
首先，我们有一个名为TechPro Ultrabook的产品。
让我们通过名称获取产品信息。
在这里，您可以看到我们刚刚获取了所有产品信息。
让我们举一个例子，获取一个类别的所有产品。
那么让我们获取计算机和笔记本电脑类别中的所有产品。
在这里你可以看到我们获取了这个类别下的所有产品。
那么让我们继续我们的例子。
为了记住我们在哪里，让我们打印用户消息。
用户消息是："告诉我关于SmartX Pro手机、相机和电视的信息。"
这就是第一步模型的初始输出。
还需要做的是阅读模型的这个输出，它是一个字符串。
我们需要将其解析成一个列表，以便输入到刚刚编写的辅助函数中。
让我们编写一个辅助函数来完成这个任务。
我们将使用Python的JSON模块。
我们将编写一个名为read_string_to_list的函数，这是函数名很直观，读取字符串到列表。
首先，我们将检查输入字符串是否为空。
如果前面的步骤中出现了问题，返回空。
现在我们将加上try except块来确保捕获任何错误。
将输入字符串中的任何单引号替换为双引号，以便
确保我们可以解析JSON。
然后使用JSON loads函数将输入的字符串解析成数组或列表。
然后将结果返回。
如果出现解码错误，就打印错误，返回none。
让我们用之前的例子测试一下。
我们将使用read_string_to_list辅助函数获取类别和产品列表
并将模型的返回结果传给它。
然后打印解析出来的列表。
它应该看起来是一样的。
让我先运行这个。
正如你所看到的，两者的内容是一样的，只是现在这个变量的类型是列表而不是字符串。
这么做的目的是用一个列表来保存这些产品信息
接下来将其添加到下一条指令给模型，生成
回答用户问题的指令。
为了做到这一点，我们需要将产品信息格式化成字符串，
然后将其添加到Prompt中。
让我们创建另一个辅助函数来完成这个任务。
我们将它命名为generate_output_string。
它将接收我们刚刚生成的数据列表。
就像这样。
然后我将复制一些代码，然后来讲解它的功能。
现在我将粘贴一些代码，给你们看一个例子，然后我们将讨论这个函数的作用。
我们将从第一个用户消息中获取产品信息。
接下来我们将在类别和产品列表上使用这个辅助函数generate_output_string，
如果你还记得的话，就是这个。
在这里，我们有了用户消息中提到的所有产品的产品信息。
我们有用户提到的手机，有用户提到的相机，还有
然后我们有所有电视的产品信息。
这些信息将有助于模型回答用户的初始问题。
如果您对这个功能的工作原理感兴趣，
我会简要概述一下，但您可以随时暂停视频并仔细阅读。
它基本上只是遍历这个列表中的所有对象，首先检查是否有产品。
如果有，它会获取每个产品的信息，然后检查是否有类别，
如果没有找到任何产品。
举例来说，这就是类别的对象。
然后它获取该类别中所有产品的产品信息，并将它们添加到此字符串中。
然后就是它返回的内容。
目前为止，我们已经找到了相关的产品信息来回答用户的问题。
现在是时候让模型来正式回复这个问题了。
那么让我们来看看系统消息。
这是指示：
“你是一家大型电子商店的客户服务助手。
以友好、有帮助的语气回答，我们可以说，非常简洁的答案。
确保向用户提出相关的后续问题。”
我们希望这对用户来说是一种互动体验。
那么，作为提醒，这是我们最初的用户消息。
我再加一次。
现在有了消息数组。
就是输入到模型的内容。
让我们来看看这个。
第一条消息，像以前一样是系统消息。
我们有用户消息。
然后还有这个额外的助手消息。
这里包含了刚刚找到的所有产品信息的消息。
这里是相关的产品信息，另起一行，然后是刚刚找到的这些产品信息。
现在模型具有回答用户问题所需的相关上下文。
那么让我们看看最后返回的结果，并打印出来。
我们希望模型能够利用产品信息中的相关信息来帮助用户。
首先，它告诉用户关于Smart X Pro手机的信息，告诉用户关于FotoSnap相机的信息，
然后谈论我们现有的不同电视，最后提出后续问题。
如您所见，通过将其分解为一系列步骤，
我们能够加载与用户查询相关的信息
为模型提供回答问题所需的相关上下文。
你可能会想，为什么我们只选择一部分产品的描述信息加载到Prompt中，
而不是包含所有产品的描述信息，让模型可以从中获取它所需的信息？
我的意思是，为什么我们不把所有产品的信息都包含在Prompt中，
这样我们就不用费心去做那些中间步骤，不用去查找产品信息了？
这其中有几个原因。
首先，包含所有产品描述可能会使模型的上下文更加混乱，
就像一个人试图一次处理大量信息。
我要说的是，对于像GPT-4这样更先进的模型，这一点相对不那么重要，
尤其是当上下文结构良好，就像这个例子中一样，
而且模型足够智能，可以忽略那些显然不相关的信息。
接下来的原因更有说服力。
第二个原因是，语言模型有上下文限制，
即允许输入和输出的固定数量的标记。
如果你有大量的产品，想象一下你有一个庞大的产品目录，
你甚至无法将所有描述放入上下文窗口中。
最后一个原因是包含所有产品描述可能会很昂贵
因为在使用语言模型时，您需要按消耗的Token付费。
因此，通过有选择地加载部分产品信息，可以降低调用的成本。
总的来说，确定何时将信息动态加载到模型的上下文中
并允许模型决定何时需要更多信息，是增强这些模型能力的最佳方法之一。
再次强调，您应该将语言模型视为一个
需要必要的上下文来推理出有用结论和执行有用任务的代理。
所以在这个例子中，我们必须给模型提供产品信息，
然后它能够根据该产品信息进行推理，为用户创建有用的答案。
在这个例子中，我们只添加了一个调用特定功能或功能的方法，根据产品名称获取产品描述，
或者根据类别名称获取类别产品。
但是，这些模型实际上擅长决定何时使用各种不同的工具，
并且可以在有指示的情况下正确使用它们。
这就是ChatGPT插件背后的原理。
我们告诉模型它可以使用哪些工具以及每个工具的功能，
当它需要从特定来源获取信息或采取其他适当行动时，它会选择使用这些工具。
在我们的例子中，我们只能通过精确的产品和类别名称来查找信息，
但还有更先进的信息检索技术。
使用文本嵌入（Text Embedding）是检索信息最有效的方法之一。
嵌入（Embedding）可以用于在大型语料库上实现高效的知识检索，以找到与给定查询相关的信息。
使用文本嵌入的一个优势是它支持模糊或语义搜索，
这样你可以使用自然语言而不是关键词找到相关信息。
所以在我们的例子中，不一定需要产品的确切名称，
但我们可以使用更通用的查询进行搜索，例如“手机”。
我们计划不久后开一个关于如何将嵌入（Embeddings）应用于各种应用的全面课程，敬请期待！
好了，让我们继续观看下一个视频，接下来我们将讨论：
“如何评估语言模型的输出结果。”